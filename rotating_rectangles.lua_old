local Vec2d = {}

function Vec2d.create(x, y)
  local o = {}
  o.x = x
  o.y = y
  setmetatable(o, {
    __index = Vec2d,
    __tostring = function()
      return "x:" .. o.x .. " y:" .. o.y .. " "
    end
  })
  return o
end

function Vec2d:rotate(deg)
  local radians = math.rad(deg)

  local x_rotated = self.x * math.cos(radians) - self.y * math.sin(radians)
  local y_rotated = self.x * math.sin(radians) + self.y * math.cos(radians)

  return Vec2d.create(
    tonumber(string.format("%.2f", x_rotated)),
    tonumber(string.format("%.2f", y_rotated)))
end

local m = {}

function m.point_to_slope(vec1, vec2)
  local slope = (vec2.y - vec1.y) / (vec2.x - vec1.x)
  return function(x)
    return slope * (x - vec1.x) + vec1.y
  end
end

function m.rotating_rectangles(a, b)
  -- Since our rectangle is centered on (0,0)
  -- we only need to rotate one point and construct the other vertexes
  local v1 = Vec2d.create(-(b / 2), a / 2):rotate(-45)
  local v2 = Vec2d.create(v1.y, v1.x)
  local v3 = Vec2d.create(-v1.x, -v1.y)
  local v4 = Vec2d.create(-v1.y, -v1.x)

  -- Line functions
  -- f(x) => y
  local a_pos = m.point_to_slope(v1, v4)
  local a_neg = m.point_to_slope(v2, v3)
  local b_pos = m.point_to_slope(v1, v2)
  local b_neg = m.point_to_slope(v3, v4)

  local count = 0
  local previous = 0

  -- For x == 0
  local std = math.abs(math.floor(a_pos(0)) - math.ceil(a_neg(0))) + 1
  print(std)
  end

print(m.rotating_rectangles(6, 4))
